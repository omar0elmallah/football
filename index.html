<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• ŸÉÿ±ÿ© ÿßŸÑŸÇÿØŸÖ ÿßŸÑÿ£ÿ≥ÿ∑Ÿàÿ±Ÿäÿ© üî•</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #e74c3c;
            --field-color: #2ecc71;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #0a3d62;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 2000px;
            height: 1000px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            overflow: hidden;
        }
        
        #game-canvas {
            background: linear-gradient(135deg, #1e5799, #2989d8);
            display: block;
        }
        
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: all 0.5s;
        }
        
        .title {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            color: #f1c40f;
            text-shadow: 0 0 15px rgba(241, 196, 15, 0.7);
            text-align: center;
            background: linear-gradient(to right, #f1c40f, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from {
                text-shadow: 0 0 10px #f1c40f;
            }
            to {
                text-shadow: 0 0 20px #e74c3c, 0 0 30px #f39c12;
            }
        }
        
        .menu-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            width: 80%;
            max-width: 500px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .menu-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #f1c40f;
            text-align: center;
        }
        .start-btn {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .option-group {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }
        
        .option-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .option-btn.selected {
            background: var(--primary-color);
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--primary-color);
        }
        
        .option-btn:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.3);
        }
        
        .color-options {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .color-option.selected {
            border-color: white;
            transform: scale(1.2);
            box-shadow: 0 0 15px currentColor;
        }
        

        
        .start-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #f39c12, #e74c3c);
        }
        
        .start-btn:active {
            transform: translateY(0);
        }
        
        .start-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }
        
        .start-btn:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }
        
        @keyframes ripple {
            0% {
                transform: scale(0, 0);
                opacity: 0.5;
            }
            20% {
                transform: scale(25, 25);
                opacity: 0.3;
            }
            100% {
                opacity: 0;
                transform: scale(40, 40);
            }
        }
        
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #score-board {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            gap: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #timer {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .goal-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 150;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        #match-result {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 2rem;
            text-align: center;
            z-index: 180;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #match-result.show {
            opacity: 1;
        }
        
        .particles {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: white;
            opacity: 0.7;
        }
        
        /* ÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿÆÿßÿµÿ© */
        .special-effects {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .power-shot {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            border-radius: 50%;
            transform: scale(0);
            animation: powerShot 0.5s forwards;
        }
        
        @keyframes powerShot {
            to {
                transform: scale(3);
                opacity: 0;
            }
        }
        
        /* ÿ™ÿ≠ÿ≥ŸäŸÜÿßÿ™ ŸÑŸÑŸàÿßÿ¨Ÿáÿ© */
        .instructions {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        .highlight {
            color: #f1c40f;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="1000" height="600"></canvas>
        
        <div id="ui-container">
            <div id="score-board">
                <span id="team1-score">0</span>
                <span>:</span>
                <span id="team2-score">0</span>
            </div>
            
            <div id="timer">03:00</div>
            
            <div id="match-result"></div>
            
            <div class="goal-effect" id="goal-effect"></div>
            
            <div class="particles" id="particles"></div>
            <div class="special-effects" id="special-effects"></div>
        </div>
        
        <div id="main-menu">
            <h1 class="title">ŸÉÿ±ÿ© ÿßŸÑŸÇÿØŸÖ ÿßŸÑÿ£ÿ≥ÿ∑Ÿàÿ±Ÿäÿ©</h1>
            
            <div class="menu-section">
                <h2 class="menu-title">ŸÜŸàÿπ ÿßŸÑŸÑÿπÿ®ÿ©</h2>
                <div class="option-group">
                    <button id="singleplayer-btn" class="option-btn selected" data-mode="single">ŸÑÿßÿπÿ® vs ŸÉŸÖÿ®ŸäŸàÿ™ÿ±</button>
                    <button id="multiplayer-btn" class="option-btn" data-mode="multi">ŸÑÿßÿπÿ® vs ŸÑÿßÿπÿ®</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h2 class="menu-title">ŸÑŸàŸÜ ŸÅÿ±ŸäŸÇŸÉ</h2>
                <div class="color-options">
                    <div class="color-option selected" style="background: #3498db;" data-color="#3498db" data-team="1"></div>
                    <div class="color-option" style="background: #e74c3c;" data-color="#e74c3c" data-team="1"></div>
                    <div class="color-option" style="background: #2ecc71;" data-color="#2ecc71" data-team="1"></div>
                    <div class="color-option" style="background: #f1c40f;" data-color="#f1c40f" data-team="1"></div>
                    <div class="color-option" style="background: #9b59b6;" data-color="#9b59b6" data-team="1"></div>
                </div>
            </div>
            
            <div class="menu-section">
                <h2 class="menu-title">ŸÑŸàŸÜ ÿßŸÑÿÆÿµŸÖ</h2>
                <div class="color-options">
                    <div class="color-option" style="background: #3498db;" data-color="#3498db" data-team="2"></div>
                    <div class="color-option selected" style="background: #e74c3c;" data-color="#e74c3c" data-team="2"></div>
                    <div class="color-option" style="background: #2ecc71;" data-color="#2ecc71" data-team="2"></div>
                    <div class="color-option" style="background: #f1c40f;" data-color="#f1c40f" data-team="2"></div>
                    <div class="color-option" style="background: #9b59b6;" data-color="#9b59b6" data-team="2"></div>
                </div>
            </div>
            
            <div class="menu-section">
                <h2 class="menu-title">ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑŸÑÿπÿ®</h2>
                <div class="instructions">
                    <p><span class="highlight">ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ:</span> ÿßŸÑÿ£ÿ≥ŸáŸÖ ŸÑŸÑÿ≠ÿ±ŸÉÿ©ÿå <span class="highlight">ŸÖÿ≥ÿßŸÅÿ©</span> ŸÑŸÑÿ∂ÿ±ÿ®ÿ© ÿßŸÑŸÇŸàŸäÿ©ÿå <span class="highlight">Shift</span> ŸÑŸÑÿ™ŸÖÿ±Ÿäÿ±</p>
                    <p><span class="highlight">ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±:</span> WASD ŸÑŸÑÿ≠ÿ±ŸÉÿ©ÿå <span class="highlight">Q</span> ŸÑŸÑÿ∂ÿ±ÿ®ÿ© ÿßŸÑŸÇŸàŸäÿ©ÿå <span class="highlight">E</span> ŸÑŸÑÿ™ŸÖÿ±Ÿäÿ±</p>
                    <p>ÿßÿ∂ÿ∫ÿ∑ ŸÖÿ∑ŸàŸÑÿßŸã ÿπŸÑŸâ ÿ≤ÿ± ÿßŸÑÿ∂ÿ±ÿ®ÿ© ŸÑÿ¥ÿ≠ŸÜ ÿ∂ÿ±ÿ®ÿ© ÿ£ŸÇŸàŸâ!</p>
                </div>
            </div>
            
            <button id="start-btn" class="start-btn">ÿ®ÿØÿ° ÿßŸÑŸÖÿ®ÿßÿ±ÿßÿ©</button>
        </div>
    </div>

    <script>
        // ====== ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ======
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const mainMenu = document.getElementById('main-menu');
        const startBtn = document.getElementById('start-btn');
        const singleplayerBtn = document.getElementById('singleplayer-btn');
        const multiplayerBtn = document.getElementById('multiplayer-btn');
        const team1ScoreEl = document.getElementById('team1-score');
        const team2ScoreEl = document.getElementById('team2-score');
        const timerEl = document.getElementById('timer');
        const matchResultEl = document.getElementById('match-result');
        const goalEffect = document.getElementById('goal-effect');
        const particlesContainer = document.getElementById('particles');
        const specialEffectsContainer = document.getElementById('special-effects');
        const colorOptions = document.querySelectorAll('.color-option');

        // ====== ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ© ======
        const config = {
            matchDuration: 180, // 3 ÿØŸÇÿßÿ¶ŸÇ
            playerSpeed: 6,
            aiSpeed: 5,
            ballStartSpeed: 5,
            maxBallSpeed: 25,
            powerShotMultiplier: 3,
            passSpeed: 12,
            attractionDistance: 120,
            attractionForce: 0.08,
            friction: 0.97,
            bounceFriction: 0.85,
            playerSize: 32,
            ballSize: 20,
            goalWidth: 180,
            postWidth: 12,
            teamSize: 3, // 3 ŸÑÿßÿπÿ®ŸäŸÜ ŸÑŸÉŸÑ ŸÅÿ±ŸäŸÇ (ÿ≠ÿßÿ±ÿ≥ÿå ŸÖÿØÿßŸÅÿπÿå ŸÖŸáÿßÿ¨ŸÖ)
            aiReactionTime: 0.3,
            aiPassProbability: 0.05,
            particleCount: 30,
            powerShotThreshold: 80 // ŸÜÿ≥ÿ®ÿ© ÿßŸÑÿ¥ÿ≠ŸÜ ŸÑŸÑÿ∂ÿ±ÿ®ÿ© ÿßŸÑŸÇŸàŸäÿ©
        };

        // ====== ÿ≠ÿßŸÑÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ© ======
        let gameRunning = false;
        let matchTime = config.matchDuration;
        let matchTimer;
        let animationFrameId;
        let lastTime = 0;
        let selectedTeam1Color = '#3498db';
        let selectedTeam2Color = '#e74c3c';
        let gameMode = 'single'; // 'single' ÿ£Ÿà 'multi'

        // ====== ŸÉÿßÿ¶ŸÜÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ© ======
        const game = {
            teams: [
                { // ÿßŸÑŸÅÿ±ŸäŸÇ 1 (ÿ£ÿ≥ŸÅŸÑ)
                    color: selectedTeam1Color,
                    players: [],
                    controlledPlayer: 1, // Ÿäÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿßŸÑŸÖŸáÿßÿ¨ŸÖ
                    score: 0,
                    controls: {
                        left: 'ArrowLeft',
                        right: 'ArrowRight',
                        up: 'ArrowUp',
                        down: 'ArrowDown',
                        kick: ' ',
                        pass: 'Shift'
                    }
                },
                { // ÿßŸÑŸÅÿ±ŸäŸÇ 2 (ÿ£ÿπŸÑŸâ)
                    color: selectedTeam2Color,
                    players: [],
                    controlledPlayer: gameMode === 'single' ? -1 : 1, // -1 ŸäÿπŸÜŸä ŸÉŸÖÿ®ŸäŸàÿ™ÿ±
                    score: 0,
                    controls: {
                        left: 'a',
                        right: 'd',
                        up: 'w',
                        down: 's',
                        kick: 'q',
                        pass: 'e'
                    }
                }
            ],
            ball: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: config.ballSize / 2,
                dx: 0,
                dy: 0,
                color: 'white',
                lastTouch: null,
                trail: []
            },
            field: {
                width: canvas.width,
                height: canvas.height,
                center: { x: canvas.width / 2, y: canvas.height / 2 },
                centerCircleRadius: 80,
                padding: 15,
                grassPattern: null
            },
            goals: [
                { // ÿßŸÑŸáÿØŸÅ ÿßŸÑÿ≥ŸÅŸÑŸä (ŸÑŸÑŸÅÿ±ŸäŸÇ 2)
                    x: canvas.width / 2 - config.goalWidth / 2,
                    y: canvas.height - 15,
                    width: config.goalWidth,
                    height: 15,
                    color: selectedTeam2Color
                },
                { // ÿßŸÑŸáÿØŸÅ ÿßŸÑÿπŸÑŸàŸä (ŸÑŸÑŸÅÿ±ŸäŸÇ 1)
                    x: canvas.width / 2 - config.goalWidth / 2,
                    y: 0,
                    width: config.goalWidth,
                    height: 15,
                    color: selectedTeam1Color
                }
            ],
            keys: {},
            matchEnded: false,
            powerShots: [] // ŸÑÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ∂ÿ±ÿ®ÿßÿ™ ÿßŸÑŸÇŸàŸäÿ©
        };

        // ====== ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÑÿπÿ®ÿ© ======
        function initGame() {
            initPlayers();
            resetBall();
            createGrassPattern();
            
            matchTime = config.matchDuration;
            updateTimerDisplay();
            game.teams[0].score = 0;
            game.teams[1].score = 0;
            updateScoreDisplay();
            
            matchResultEl.classList.remove('show');
            matchResultEl.style.opacity = '0';
            matchResultEl.innerHTML = '';
            
            game.matchEnded = false;
            game.powerShots = [];
        }

        function initPlayers() {
            game.teams[0].color = selectedTeam1Color;
            game.teams[1].color = selectedTeam2Color;
            game.goals[0].color = selectedTeam2Color;
            game.goals[1].color = selectedTeam1Color;
            
            // ÿ™ÿ≠ÿØŸäÿØ Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÑŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ´ÿßŸÜŸä
            game.teams[1].controlledPlayer = gameMode === 'single' ? -1 : 1;
            
            game.teams.forEach((team, teamIndex) => {
                team.players = [];
                
                // ÿ≠ÿßÿ±ÿ≥ ÿßŸÑŸÖÿ±ŸÖŸâ
                team.players.push({
                    x: canvas.width / 2 - config.playerSize / 2,
                    y: teamIndex === 0 ? canvas.height - 50 : 30,
                    width: config.playerSize,
                    height: config.playerSize,
                    color: team.color,
                    speed: teamIndex === 1 && team.controlledPlayer === -1 ? config.aiSpeed : config.playerSpeed,
                    dx: 0,
                    dy: 0,
                    power: 0,
                    isCharging: false,
                    isControlled: false,
                    team: teamIndex,
                    role: 'goalkeeper',
                    target: { x: canvas.width / 2 - config.playerSize / 2, y: teamIndex === 0 ? canvas.height - 50 : 30 },
                    state: 'goalkeeping'
                });
                
                // ŸÖÿØÿßŸÅÿπ
                team.players.push({
                    x: canvas.width / 2 - config.playerSize / 2,
                    y: teamIndex === 0 ? canvas.height - 120 : 80,
                    width: config.playerSize,
                    height: config.playerSize,
                    color: team.color,
                    speed: teamIndex === 1 && team.controlledPlayer === -1 ? config.aiSpeed : config.playerSpeed,
                    dx: 0,
                    dy: 0,
                    power: 0,
                    isCharging: false,
                    isControlled: false,
                    team: teamIndex,
                    role: 'defender',
                    target: { x: canvas.width / 2 - config.playerSize / 2, y: teamIndex === 0 ? canvas.height - 120 : 80 },
                    state: 'defending'
                });
                
                // ŸÖŸáÿßÿ¨ŸÖ
                team.players.push({
                    x: canvas.width / 2 - config.playerSize / 2,
                    y: teamIndex === 0 ? canvas.height - 200 : 150,
                    width: config.playerSize,
                    height: config.playerSize,
                    color: team.color,
                    speed: config.playerSpeed,
                    dx: 0,
                    dy: 0,
                    power: 0,
                    isCharging: false,
                    isControlled: team.controlledPlayer === 1,
                    team: teamIndex,
                    role: 'attacker',
                    target: { x: canvas.width / 2 - config.playerSize / 2, y: teamIndex === 0 ? canvas.height - 200 : 150 },
                    state: 'attacking'
                });
            });
        }

        function createGrassPattern() {
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = 60;
            patternCanvas.height = 60;
            const patternCtx = patternCanvas.getContext('2d');
            
            patternCtx.fillStyle = '#2ecc71';
            patternCtx.fillRect(0, 0, 60, 60);
            
            patternCtx.strokeStyle = '#27ae60';
            patternCtx.lineWidth = 2;
            
            // ÿÆÿ∑Ÿàÿ∑ ŸÖÿ™ŸÇÿßÿ∑ÿπÿ©
            for (let i = 0; i <= 60; i += 10) {
                patternCtx.beginPath();
                patternCtx.moveTo(i, 0);
                patternCtx.lineTo(i, 60);
                patternCtx.stroke();
                
                patternCtx.beginPath();
                patternCtx.moveTo(0, i);
                patternCtx.lineTo(60, i);
                patternCtx.stroke();
            }
            
            game.field.grassPattern = ctx.createPattern(patternCanvas, 'repeat');
        }

        // ====== ÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ======
        startBtn.addEventListener('click', () => {
            startBtn.style.animation = 'pulse 0.5s';
            setTimeout(() => {
                mainMenu.style.display = 'none';
                initGame();
                startMatch();
                startBtn.style.animation = '';
            }, 500);
        });

        singleplayerBtn.addEventListener('click', () => {
            gameMode = 'single';
            singleplayerBtn.classList.add('selected');
            multiplayerBtn.classList.remove('selected');
        });

        multiplayerBtn.addEventListener('click', () => {
            gameMode = 'multi';
            multiplayerBtn.classList.add('selected');
            singleplayerBtn.classList.remove('selected');
        });

        colorOptions.forEach(option => {
            option.addEventListener('click', () => {
                const team = option.dataset.team;
                const color = option.dataset.color;
                
                document.querySelectorAll(`.color-option[data-team="${team}"]`).forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                option.classList.add('selected');
                
                if (team === '1') {
                    selectedTeam1Color = color;
                } else {
                    selectedTeam2Color = color;
                }
            });
        });

        window.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            game.keys[e.key] = true;
            
            game.teams.forEach(team => {
                const player = team.players[team.controlledPlayer];
                if (player && e.key === team.controls.kick) {
                    player.isCharging = true;
                }
                
                if (player && e.key === team.controls.pass) {
                    passBall(player);
                }
            });
        });

        window.addEventListener('keyup', (e) => {
            if (!gameRunning) return;
            
            game.keys[e.key] = false;
            
            game.teams.forEach(team => {
                const player = team.players[team.controlledPlayer];
                if (player && e.key === team.controls.kick && player.isCharging) {
                    kickBall(player);
                    player.isCharging = false;
                    player.power = 0;
                }
            });
        });

        // ====== Ÿàÿ∏ÿßÿ¶ŸÅ ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ======
        function startMatch() {
            gameRunning = true;
            
            matchTimer = setInterval(() => {
                matchTime--;
                updateTimerDisplay();
                
                if (matchTime <= 0) {
                    endMatch();
                }
            }, 1000);
            
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endMatch() {
            gameRunning = false;
            game.matchEnded = true;
            clearInterval(matchTimer);
            cancelAnimationFrame(animationFrameId);
            
            let resultText = '';
            if (game.teams[0].score > game.teams[1].score) {
                resultText = `üèÜ ŸÅŸàÿ≤ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ${game.teams[0].score}-${game.teams[1].score} üèÜ`;
            } else if (game.teams[1].score > game.teams[0].score) {
                resultText = `üèÜ ŸÅŸàÿ≤ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ${game.teams[1].score}-${game.teams[0].score} üèÜ`;
            } else {
                resultText = `‚öΩ ÿ™ÿπÿßÿØŸÑ ${game.teams[0].score}-${game.teams[1].score} ‚öΩ`;
            }
            
            matchResultEl.textContent = resultText;
            matchResultEl.classList.add('show');
            matchResultEl.style.opacity = '1';
            
            setTimeout(() => {
                const replayBtn = document.createElement('button');
                replayBtn.textContent = 'ŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ';
                replayBtn.className = 'start-btn';
                replayBtn.style.marginTop = '20px';
                replayBtn.style.pointerEvents = 'all';
                replayBtn.addEventListener('click', () => {
                    mainMenu.style.display = 'flex';
                    matchResultEl.innerHTML = '';
                    matchResultEl.classList.remove('show');
                });
                
                matchResultEl.appendChild(replayBtn);
            }, 2000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(matchTime / 60).toString().padStart(2, '0');
            const seconds = (matchTime % 60).toString().padStart(2, '0');
            timerEl.textContent = `${minutes}:${seconds}`;
            
            if (matchTime <= 10) {
                timerEl.style.color = '#ff0000';
                timerEl.style.animation = 'pulse 0.5s infinite alternate';
            } else {
                timerEl.style.color = '';
                timerEl.style.animation = '';
            }
        }

        function updateScoreDisplay() {
            team1ScoreEl.textContent = game.teams[0].score;
            team2ScoreEl.textContent = game.teams[1].score;
            
            // ÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÜÿØ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©
            team1ScoreEl.style.transform = 'scale(1.2)';
            team2ScoreEl.style.transform = 'scale(1.2)';
            setTimeout(() => {
                team1ScoreEl.style.transform = 'scale(1)';
                team2ScoreEl.style.transform = 'scale(1)';
            }, 200);
        }

        function resetBall() {
            game.ball.x = canvas.width / 2;
            game.ball.y = canvas.height / 2;
            
            const angle = Math.random() * Math.PI * 2;
            game.ball.dx = Math.cos(angle) * config.ballStartSpeed;
            game.ball.dy = Math.sin(angle) * config.ballStartSpeed;
            game.ball.lastTouch = null;
            game.ball.trail = [];
        }

        // ====== ŸÖŸäŸÉÿßŸÜŸäŸÉÿß ÿßŸÑŸÑÿπÿ®ÿ© ======
        function kickBall(player) {
            const dx = game.ball.x - (player.x + player.width / 2);
            const dy = game.ball.y - (player.y + player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 80) {
                const angle = Math.atan2(dy, dx);
                let power = player.power * config.powerShotMultiplier + 3;
                
                // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ∂ÿ±ÿ®ÿ© ŸÇŸàŸäÿ©
                if (player.power > config.powerShotThreshold) {
                    power *= 1.5;
                    createPowerShotEffect(player.x + player.width/2, player.y + player.height/2, angle);
                }
                
                game.ball.dx = Math.cos(angle) * power;
                game.ball.dy = Math.sin(angle) * power;
                game.ball.lastTouch = player.team;
                
                limitBallSpeed();
                createParticles(player.x + player.width/2, player.y + player.height/2, player.color);
                playSound('kick');
            }
        }

        function createPowerShotEffect(x, y, angle) {
            const effect = document.createElement('div');
            effect.className = 'power-shot';
            effect.style.left = `${x - 50}px`;
            effect.style.top = `${y - 50}px`;
            effect.style.transform = `rotate(${angle}rad)`;
            specialEffectsContainer.appendChild(effect);
            
            setTimeout(() => {
                specialEffectsContainer.removeChild(effect);
            }, 500);
        }

        function passBall(player) {
            const dx = game.ball.x - (player.x + player.width / 2);
            const dy = game.ball.y - (player.y + player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 80) {
                let bestTeammate = null;
                let bestScore = -Infinity;
                
                game.teams[player.team].players.forEach(teammate => {
                    if (teammate !== player) {
                        const goal = game.goals[player.team === 0 ? 1 : 0];
                        const distToGoal = Math.sqrt(
                            Math.pow(teammate.x + teammate.width/2 - (goal.x + goal.width/2), 2) + 
                            Math.pow(teammate.y + teammate.height/2 - (goal.y + goal.height/2), 2)
                        );
                        
                        const distFromPlayer = Math.sqrt(
                            Math.pow(teammate.x + teammate.width/2 - (player.x + player.width/2), 2) + 
                            Math.pow(teammate.y + teammate.height/2 - (player.y + player.height/2), 2)
                        );
                        
                        let distFromOpponents = Infinity;
                        game.teams[player.team === 0 ? 1 : 0].players.forEach(opponent => {
                            const dist = Math.sqrt(
                                Math.pow(teammate.x + teammate.width/2 - (opponent.x + opponent.width/2), 2) + 
                                Math.pow(teammate.y + teammate.height/2 - (opponent.y + opponent.height/2), 2)
                            );
                            if (dist < distFromOpponents) distFromOpponents = dist;
                        });
                        
                        let score = 0;
                        if (teammate.role === 'goalkeeper') score -= 50; // ŸÑÿß ŸÜŸÖÿ±ÿ± ŸÑÿ≠ÿßÿ±ÿ≥ ÿßŸÑŸÖÿ±ŸÖŸâ
                        else if (teammate.role === 'attacker') score += 50;
                        
                        score += (canvas.width - distToGoal) * 0.5;
                        score += distFromOpponents * 0.8;
                        score -= distFromPlayer * 0.3;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestTeammate = teammate;
                        }
                    }
                });
                
                if (bestTeammate) {
                    const targetX = bestTeammate.x + bestTeammate.width/2;
                    const targetY = bestTeammate.y + bestTeammate.height/2;
                    const angle = Math.atan2(
                        targetY - (player.y + player.height/2),
                        targetX - (player.x + player.width/2)
                    );
                    
                    game.ball.dx = Math.cos(angle) * config.passSpeed;
                    game.ball.dy = Math.sin(angle) * config.passSpeed;
                    game.ball.lastTouch = player.team;
                    limitBallSpeed();
                    
                    createParticles(player.x + player.width/2, player.y + player.height/2, player.color);
                    playSound('pass');
                }
            }
        }

        function limitBallSpeed() {
            const speed = Math.sqrt(game.ball.dx * game.ball.dx + game.ball.dy * game.ball.dy);
            if (speed > config.maxBallSpeed) {
                game.ball.dx = (game.ball.dx / speed) * config.maxBallSpeed;
                game.ball.dy = (game.ball.dy / speed) * config.maxBallSpeed;
            }
        }

        function moveAIPlayers() {
            game.teams.forEach((team, teamIndex) => {
                // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿ™ÿ≠ÿ™ ÿ≥Ÿäÿ∑ÿ±ÿ© ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ±
                if (teamIndex === 1 && team.controlledPlayer === -1) {
                    team.players.forEach(player => {
                        player.reactionTime -= 1/60;
                        
                        if (player.reactionTime <= 0) {
                            player.reactionTime = config.aiReactionTime * (0.8 + Math.random() * 0.4);
                            updateAIState(player);
                            
                            switch (player.state) {
                                case 'defending': handleDefense(player); break;
                                case 'attacking': handleAttack(player); break;
                                case 'goalkeeping': handleGoalkeeping(player); break;
                                default: handlePositioning(player);
                            }
                        }
                        
                        const dx = player.target.x - (player.x + player.width/2);
                        const dy = player.target.y - (player.y + player.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 5) {
                            player.dx = (dx / distance) * player.speed;
                            player.dy = (dy / distance) * player.speed;
                        } else {
                            player.dx = 0;
                            player.dy = 0;
                        }
                        
                        player.x += player.dx;
                        player.y += player.dy;
                        
                        player.x = Math.max(config.playerSize/2, Math.min(canvas.width - config.playerSize/2, player.x));
                        player.y = Math.max(config.playerSize/2, Math.min(canvas.height - config.playerSize/2, player.y));
                    });
                }
            });
        }

        function updateAIState(player) {
            const ballDist = Math.sqrt(
                Math.pow(game.ball.x - (player.x + player.width/2), 2) + 
                Math.pow(game.ball.y - (player.y + player.height/2), 2)
            );
            
            if (player.role === 'goalkeeper') {
                player.state = 'goalkeeping';
                return;
            }
            
            if (ballDist < 200) {
                if (game.ball.lastTouch === player.team) {
                    if (player.role === 'attacker') {
                        player.state = 'attacking';
                    } else {
                        player.state = 'supporting';
                    }
                } else {
                    player.state = 'defending';
                }
            } else {
                player.state = 'positioning';
            }
        }

        function handleDefense(player) {
            const ballDist = Math.sqrt(
                Math.pow(game.ball.x - (player.x + player.width/2), 2) + 
                Math.pow(game.ball.y - (player.y + player.height/2), 2)
            );
            
            if (ballDist < 50) {
                player.target.x = game.ball.x - player.width/2;
                player.target.y = game.ball.y - player.height/2;
                
                if (Math.random() < 0.1) {
                    kickBall(player);
                }
            } else {
                const goal = game.goals[player.team];
                const targetX = game.ball.x * 0.7 + (goal.x + goal.width/2) * 0.3;
                const targetY = game.ball.y * 0.7 + (goal.y + goal.height/2) * 0.3;
                
                player.target.x = targetX - player.width/2;
                player.target.y = targetY - player.height/2;
            }
        }

        function handleAttack(player) {
            if (game.ball.lastTouch === player.team) {
                const goal = game.goals[player.team === 0 ? 1 : 0];
                
                const ballDist = Math.sqrt(
                    Math.pow(game.ball.x - (player.x + player.width/2), 2) + 
                    Math.pow(game.ball.y - (player.y + player.height/2), 2)
                );
                
                if (ballDist < 60) {
                    if (Math.random() < 0.7) {
                        player.isCharging = true;
                        player.power = 50 + Math.random() * 50;
                        setTimeout(() => {
                            kickBall(player);
                            player.isCharging = false;
                            player.power = 0;
                        }, 300 + Math.random() * 500);
                    } else if (Math.random() < config.aiPassProbability) {
                        passBall(player);
                    }
                }
                
                const attackPositions = [
                    { x: goal.x + goal.width * 0.3, y: goal.y + (player.team === 0 ? -80 : 80) },
                    { x: goal.x + goal.width * 0.7, y: goal.y + (player.team === 0 ? -80 : 80) },
                    { x: canvas.width / 2, y: goal.y + (player.team === 0 ? -120 : 120) }
                ];
                
                const pos = attackPositions[Math.floor(Math.random() * attackPositions.length)];
                player.target.x = pos.x - player.width/2;
                player.target.y = pos.y - player.height/2;
            } else {
                const ballHolder = findClosestPlayer(game.ball.x, game.ball.y, game.teams[player.team === 0 ? 1 : 0].players);
                if (ballHolder) {
                    player.target.x = ballHolder.x;
                    player.target.y = ballHolder.y;
                }
            }
        }

        function handleGoalkeeping(player) {
            const goal = game.goals[player.team];
            
            const ballDistToGoal = Math.sqrt(
                Math.pow(game.ball.x - (goal.x + goal.width/2), 2) + 
                Math.pow(game.ball.y - (goal.y + goal.height/2), 2)
            );
            
            if (ballDistToGoal < 250) {
                const targetX = game.ball.x * 0.8 + (goal.x + goal.width/2) * 0.2;
                const targetY = goal.y + goal.height/2;
                
                player.target.x = Math.max(goal.x, Math.min(goal.x + goal.width, targetX)) - player.width/2;
                player.target.y = targetY - player.height/2;
                
                const ballDist = Math.sqrt(
                    Math.pow(game.ball.x - (player.x + player.width/2), 2) + 
                    Math.pow(game.ball.y - (player.y + player.height/2), 2)
                );
                
                if (ballDist < 40 && Math.random() < 0.3) {
                    kickBall(player);
                }
            } else {
                player.target.x = (goal.x + goal.width/2) - player.width/2;
                player.target.y = (goal.y + goal.height/2) - player.height/2;
            }
        }

        function handlePositioning(player) {
            let basePos;
            
            switch (player.role) {
                case 'defender':
                    basePos = {
                        x: canvas.width / 2,
                        y: player.team === 0 ? canvas.height - 120 : 80
                    };
                    break;
                case 'attacker':
                    basePos = {
                        x: canvas.width / 2,
                        y: player.team === 0 ? canvas.height - 200 : 150
                    };
                    break;
                default:
                    basePos = { x: canvas.width / 2, y: canvas.height / 2 };
            }
            
            // ÿ®ÿπÿ∂ ÿßŸÑÿ™ÿ®ÿßŸäŸÜ ŸÅŸä ÿßŸÑŸÖŸàÿ∂ÿπ
            basePos.x += (Math.random() - 0.5) * 50;
            basePos.y += (Math.random() - 0.5) * 30;
            
            player.target.x = basePos.x - player.width/2;
            player.target.y = basePos.y - player.height/2;
        }

        function findClosestPlayer(x, y, players) {
            let closestPlayer = null;
            let minDistance = Infinity;
            
            players.forEach(player => {
                const distance = Math.sqrt(
                    Math.pow(x - (player.x + player.width/2), 2) + 
                    Math.pow(y - (player.y + player.height/2), 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPlayer = player;
                }
            });
            
            return closestPlayer;
        }

        function applyBallAttraction() {
            const ballSpeed = Math.sqrt(game.ball.dx * game.ball.dx + game.ball.dy * game.ball.dy);
            if (ballSpeed > 8) return;
            
            let closestPlayer = null;
            let minDistance = Infinity;
            
            game.teams.forEach(team => {
                team.players.forEach(player => {
                    const dx = game.ball.x - (player.x + player.width/2);
                    const dy = game.ball.y - (player.y + player.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < config.attractionDistance && distance < minDistance) {
                        minDistance = distance;
                        closestPlayer = player;
                    }
                });
            });
            
            if (closestPlayer && minDistance > 20) {
                const dx = (closestPlayer.x + closestPlayer.width/2) - game.ball.x;
                const dy = (closestPlayer.y + closestPlayer.height/2) - game.ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const force = config.attractionForce * (1 - (distance / config.attractionDistance));
                
                game.ball.dx += dx / distance * force;
                game.ball.dy += dy / distance * force;
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < config.particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.background = color;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                const lifetime = 500 + Math.random() * 500;
                
                particlesContainer.appendChild(particle);
                
                let startTime = performance.now();
                function animateParticle(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = elapsed / lifetime;
                    
                    if (progress < 1) {
                        const distance = speed * elapsed / 50;
                        particle.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                        particle.style.opacity = 1 - progress;
                        requestAnimationFrame(animateParticle);
                    } else {
                        particlesContainer.removeChild(particle);
                    }
                }
                
                requestAnimationFrame(animateParticle);
            }
        }

        function playSound(type) {
            // ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ∂ÿßŸÅÿ© ÿ£ÿµŸàÿßÿ™ ÿ≠ŸÇŸäŸÇŸäÿ© ŸáŸÜÿß
            console.log('Playing sound:', type);
        }

        function showGoalEffect(teamIndex) {
            const color = teamIndex === 0 ? selectedTeam1Color : selectedTeam2Color;
            goalEffect.style.backgroundColor = color;
            goalEffect.style.opacity = '0.8';
            
            // ÿ¨ÿ≥ŸäŸÖÿßÿ™ ÿßÿ≠ÿ™ŸÅÿßŸÑŸäÿ©
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    createParticles(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        color
                    );
                }, i * 50);
            }
            
            // ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸáÿ™ÿ≤ÿßÿ≤
            canvas.style.animation = 'shake 0.5s';
            setTimeout(() => {
                canvas.style.animation = '';
            }, 500);
            
            setTimeout(() => {
                goalEffect.style.opacity = '0';
            }, 1000);
        }

        // ====== ŸÜÿ∏ÿßŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ£ŸáÿØÿßŸÅ ÿßŸÑÿ∞ŸÉŸä ======
        function checkGoals() {
            game.goals.forEach((goal, index) => {
                if (isBallInGoal(goal)) {
                    const scoringTeamIndex = index === 0 ? 1 : 0;
                    
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÉÿ±ÿ© ŸÑŸÖ ÿ™ÿØÿÆŸÑ ŸÖÿ±ŸÖŸâ ÿßŸÑŸÅÿ±ŸäŸÇ ŸÜŸÅÿ≥Ÿá
                    if (game.ball.lastTouch !== scoringTeamIndex) {
                        game.teams[scoringTeamIndex].score++;
                        updateScoreDisplay();
                        showGoalEffect(scoringTeamIndex);
                        
                        // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÉÿ±ÿ© ÿ®ÿπÿØ ÿ™ÿ£ÿÆŸäÿ±
                        if (!game.matchEnded) {
                            setTimeout(resetBall, 1000);
                        }
                    } else {
                        // ÿ•ÿ∞ÿß ÿØÿÆŸÑÿ™ ÿßŸÑŸÉÿ±ÿ© ŸÖÿ±ŸÖŸâ ÿßŸÑŸÅÿ±ŸäŸÇ ŸÜŸÅÿ≥Ÿáÿå ŸÑÿß ÿ™ÿ≠ÿ™ÿ≥ÿ®
                        setTimeout(resetBall, 500);
                    }
                }
            });
        }

        function isBallInGoal(goal) {
            return (
                game.ball.x + game.ball.radius > goal.x &&
                game.ball.x - game.ball.radius < goal.x + goal.width &&
                game.ball.y + game.ball.radius > goal.y &&
                game.ball.y - game.ball.radius < goal.y + goal.height
            );
        }

        // ====== ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÑÿπÿ®ÿ© ======
        function update(deltaTime) {
            const deltaSeconds = deltaTime / 1000;
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿ¥ÿ≠ŸÜ ÿßŸÑÿ∂ÿ±ÿ®ÿ© ŸÑŸÑÿßÿπÿ®ŸäŸÜ
            game.teams.forEach(team => {
                const player = team.players[team.controlledPlayer];
                if (player && player.isCharging && player.power < 100) {
                    player.power += deltaSeconds * 50;
                    if (player.power > 100) player.power = 100;
                }
            });
            
            // ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑŸÖÿ™ÿ≠ŸÉŸÖ ÿ®ŸáŸÖ
            game.teams.forEach(team => {
                const player = team.players[team.controlledPlayer];
                if (player) {
                    player.dx = 0;
                    player.dy = 0;
                    
                    if (game.keys[team.controls.left]) player.dx = -player.speed;
                    if (game.keys[team.controls.right]) player.dx = player.speed;
                    if (game.keys[team.controls.up]) player.dy = -player.speed;
                    if (game.keys[team.controls.down]) player.dy = player.speed;
                    
                    player.x += player.dx * deltaSeconds * 60;
                    player.y += player.dy * deltaSeconds * 60;
                    
                    player.x = Math.max(config.playerSize/2, Math.min(canvas.width - config.playerSize/2, player.x));
                    player.y = Math.max(config.playerSize/2, Math.min(canvas.height - config.playerSize/2, player.y));
                }
            });
            
            // ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑÿ¢ŸÑŸäŸäŸÜ
            moveAIPlayers();
            
            // ÿßŸÜÿ¨ÿ∞ÿßÿ® ÿßŸÑŸÉÿ±ÿ© ŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑŸÇÿ±Ÿäÿ®ŸäŸÜ
            applyBallAttraction();
            
            // ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÉÿ±ÿ©
            game.ball.x += game.ball.dx * deltaSeconds * 60;
            game.ball.y += game.ball.dy * deltaSeconds * 60;
            
            game.ball.dx *= Math.pow(config.friction, deltaSeconds * 60);
            game.ball.dy *= Math.pow(config.friction, deltaSeconds * 60);
            
            // ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸàŸÇÿπ ÿßŸÑŸÉÿ±ÿ© ÿ•ŸÑŸâ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ©
            game.ball.trail.push({ x: game.ball.x, y: game.ball.y });
            if (game.ball.trail.length > 10) {
                game.ball.trail.shift();
            }
            
            // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ≥ÿ±ÿπÿ© ÿßŸÑŸÉÿ±ÿ© ÿ®ÿ∑Ÿäÿ¶ÿ© ÿ¨ÿØŸãÿßÿå ÿ™ŸàŸÇŸÅ
            const ballSpeed = Math.sqrt(game.ball.dx * game.ball.dx + game.ball.dy * game.ball.dy);
            if (ballSpeed < 0.1) {
                game.ball.dx = 0;
                game.ball.dy = 0;
            }
            
            // ÿßÿ±ÿ™ÿØÿßÿØ ÿßŸÑŸÉÿ±ÿ© ŸÖŸÜ ÿßŸÑÿ¨ÿØÿ±ÿßŸÜ
            if (game.ball.x - game.ball.radius < game.field.padding) {
                game.ball.x = game.field.padding + game.ball.radius;
                game.ball.dx *= -config.bounceFriction;
                playSound('wall');
            }
            if (game.ball.x + game.ball.radius > canvas.width - game.field.padding) {
                game.ball.x = canvas.width - game.field.padding - game.ball.radius;
                game.ball.dx *= -config.bounceFriction;
                playSound('wall');
            }
            if (game.ball.y - game.ball.radius < game.field.padding) {
                game.ball.y = game.field.padding + game.ball.radius;
                game.ball.dy *= -config.bounceFriction;
                playSound('wall');
            }
            if (game.ball.y + game.ball.radius > canvas.height - game.field.padding) {
                game.ball.y = canvas.height - game.field.padding - game.ball.radius;
                game.ball.dy *= -config.bounceFriction;
                playSound('wall');
            }
            
            // ÿßÿ±ÿ™ÿØÿßÿØ ÿßŸÑŸÉÿ±ÿ© ŸÖŸÜ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ
            game.teams.forEach(team => {
                team.players.forEach(player => {
                    if (
                        game.ball.x + game.ball.radius > player.x &&
                        game.ball.x - game.ball.radius < player.x + player.width &&
                        game.ball.y + game.ball.radius > player.y &&
                        game.ball.y - game.ball.radius < player.y + player.height
                    ) {
                        const angle = Math.atan2(
                            game.ball.y - (player.y + player.height / 2),
                            game.ball.x - (player.x + player.width / 2)
                        );
                        
                        const playerSpeed = Math.sqrt(player.dx * player.dx + player.dy * player.dy);
                        const power = playerSpeed * 0.7 + 3;
                        
                        game.ball.dx = Math.cos(angle) * power;
                        game.ball.dy = Math.sin(angle) * power;
                        game.ball.lastTouch = player.team;
                        limitBallSpeed();
                        
                        createParticles(
                            game.ball.x, 
                            game.ball.y,
                            player.team === 0 ? selectedTeam1Color : selectedTeam2Color
                        );
                        
                        playSound('hit');
                    }
                });
            });
            
            // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ£ŸáÿØÿßŸÅ
            checkGoals();
        }

        // ====== ÿ±ÿ≥ŸÖ ÿßŸÑŸÑÿπÿ®ÿ© ======
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ÿ±ÿ≥ŸÖ ÿßŸÑÿπÿ¥ÿ®
            ctx.fillStyle = game.field.grassPattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÿ≠ÿØŸàÿØ ÿßŸÑŸÖŸÑÿπÿ®
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.strokeRect(
                game.field.padding, 
                game.field.padding, 
                canvas.width - game.field.padding * 2, 
                canvas.height - game.field.padding * 2
            );
            
            // ÿÆÿ∑ ÿßŸÑŸÖŸÜÿ™ÿµŸÅ
            ctx.beginPath();
            ctx.moveTo(game.field.padding, canvas.height / 2);
            ctx.lineTo(canvas.width - game.field.padding, canvas.height / 2);
            ctx.stroke();
            
            // ÿØÿßÿ¶ÿ±ÿ© ÿßŸÑŸÖŸÜÿ™ÿµŸÅ
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, game.field.centerCircleRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ŸÜŸÇÿ∑ÿ© ÿßŸÑŸÖŸÜÿ™ÿµŸÅ
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            
            // ÿ±ÿ≥ŸÖ ÿßŸÑÿ£ŸáÿØÿßŸÅ
            game.goals.forEach(goal => {
                ctx.fillStyle = goal.color;
                ctx.fillRect(goal.x, goal.y, goal.width, goal.height);
                
                ctx.fillStyle = 'white';
                ctx.fillRect(goal.x - config.postWidth, goal.y, config.postWidth, goal.height * 3);
                ctx.fillRect(goal.x + goal.width, goal.y, config.postWidth, goal.height * 3);
            });
            
            // ÿ±ÿ≥ŸÖ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ
            game.teams.forEach(team => {
                team.players.forEach(player => {
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                    
                    if (player.isControlled) {
                        ctx.strokeStyle = 'yellow';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(player.x - 2, player.y - 2, player.width + 4, player.height + 4);
                    }
                    
                    // ÿ±ÿ≥ŸÖ ÿ±ŸÇŸÖ ÿßŸÑŸÑÿßÿπÿ®
                    ctx.fillStyle = 'white';
                    ctx.font = `${config.playerSize * 0.5}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let playerNumber = '';
                    if (player.role === 'goalkeeper') playerNumber = '1';
                    else if (player.role === 'defender') playerNumber = '2';
                    else if (player.role === 'attacker') playerNumber = '3';
                    ctx.fillText(playerNumber, player.x + player.width/2, player.y + player.height/2);
                });
            });
            
            // ÿ±ÿ≥ŸÖ ÿßŸÑŸÉÿ±ÿ©
            const ballSpeed = Math.sqrt(game.ball.dx * game.ball.dx + game.ball.dy * game.ball.dy);
            const rotationAngle = (performance.now() * 0.02 * ballSpeed) % (Math.PI * 2);
            
            const gradient = ctx.createRadialGradient(
                game.ball.x - game.ball.radius * 0.3,
                game.ball.y - game.ball.radius * 0.3,
                0,
                game.ball.x,
                game.ball.y,
                game.ball.radius
            );
            gradient.addColorStop(0, '#f5f5f5');
            gradient.addColorStop(1, '#bdbdbd');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(game.ball.x, game.ball.y, game.ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÉÿ±ÿ©
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1.5;
            
            for (let i = 0; i < 3; i++) {
                const angle = rotationAngle + (i * Math.PI * 2 / 3);
                ctx.beginPath();
                ctx.arc(
                    game.ball.x, 
                    game.ball.y, 
                    game.ball.radius * 0.9, 
                    angle - 0.3, 
                    angle + 0.3
                );
                ctx.stroke();
            }
            
            // ÿ∞ŸäŸÑ ÿßŸÑŸÉÿ±ÿ© ÿπŸÜÿØ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©
            if (ballSpeed > 10) {
                const angle = Math.atan2(game.ball.dy, game.ball.dx);
                const trailLength = Math.min(30, ballSpeed * 2);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(game.ball.x, game.ball.y);
                ctx.lineTo(
                    game.ball.x - Math.cos(angle) * trailLength,
                    game.ball.y - Math.sin(angle) * trailLength
                );
                ctx.stroke();
            }
        }

        // ====== ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ======
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (gameRunning) {
                update(deltaTime);
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ© ÿπŸÜÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸÅÿ≠ÿ©
        window.addEventListener('load', () => {
            createGrassPattern();
            draw();
        });
    </script>
</body>
</html>
